use bitnet_core::memory::HybridMemoryPool;
use bitnet_core::tensor::core::BitNetTensor;
use bitnet_core::tensor::dtype::BitNetDType;
use bitnet_core::tensor::memory_integration::set_global_memory_pool;
use bitnet_core::tensor::ops::TensorOpError;
use candle_core::Device;
use std::sync::Arc;

/// Simple infrastructure validation test that only uses existing APIs
/// This validates that our testing framework structure works correctly
/// without depending on missing BitNetTensor methods
#[test]
fn test_infrastructure_validation() -> Result<(), Box<dyn std::error::Error>> {
    // Test memory pool creation (existing API)
    let memory_pool = Arc::new(HybridMemoryPool::new()?);
    
    // Set up global memory pool for tensor creation
    set_global_memory_pool(Arc::downgrade(&memory_pool));

    // Test basic tensor creation (existing API)
    let device = Device::Cpu;
    let tensor = BitNetTensor::zeros(&[2, 2], BitNetDType::F32, Some(device))?;

    // Validate tensor properties
    assert_eq!(tensor.dtype(), BitNetDType::F32);
    assert_eq!(tensor.device().location(), candle_core::DeviceLocation::Cpu);

    // Test shape validation
    let shape = tensor.shape();
    let dims = shape.dims();
    assert_eq!(dims.len(), 2);
    assert_eq!(dims[0], 2);
    assert_eq!(dims[1], 2);

    println!("✅ Infrastructure validation test passed!");
    Ok(())
}

/// Test error handling framework
#[test]
fn test_error_handling_infrastructure() {
    // Test that we can create and handle TensorOpError variants (existing ones)
    let error = TensorOpError::DTypeMismatch {
        operation: "test_operation".to_string(),
        reason: "Testing error handling infrastructure".to_string(),
    };

    match error {
        TensorOpError::DTypeMismatch { operation, reason } => {
            assert_eq!(operation, "test_operation");
            assert!(!reason.is_empty());
        }
        _ => panic!("Expected DTypeMismatch error"),
    }

    println!("✅ Error handling infrastructure test passed!");
}

/// Test memory pool integration
#[test]
fn test_memory_integration() -> Result<(), Box<dyn std::error::Error>> {
    let memory_pool = Arc::new(HybridMemoryPool::new()?);
    
    // Set up global memory pool for tensor creation
    set_global_memory_pool(Arc::downgrade(&memory_pool));

    // Create multiple tensors to test memory allocation
    let device = Device::Cpu;
    let tensor1 = BitNetTensor::zeros(&[10, 10], BitNetDType::F32, Some(device.clone()))?;
    let tensor2 = BitNetTensor::ones(&[5, 5], BitNetDType::F32, Some(device))?;

    // Validate both tensors were created successfully
    assert_eq!(tensor1.dtype(), BitNetDType::F32);
    assert_eq!(tensor2.dtype(), BitNetDType::F32);

    println!("✅ Memory integration test passed!");
    Ok(())
}

/// Test tensor creation patterns
#[test]
fn test_tensor_creation_patterns() -> Result<(), Box<dyn std::error::Error>> {
    let memory_pool = Arc::new(HybridMemoryPool::new()?);
    
    // Set up global memory pool for tensor creation
    set_global_memory_pool(Arc::downgrade(&memory_pool));
    
    let device = Device::Cpu;

    // Test different creation methods
    let zeros_tensor = BitNetTensor::zeros(&[3, 3], BitNetDType::F32, Some(device.clone()))?;
    let ones_tensor = BitNetTensor::ones(&[3, 3], BitNetDType::F32, Some(device.clone()))?;

    // Test different data types
    let i32_tensor = BitNetTensor::zeros(&[2, 2], BitNetDType::I32, Some(device.clone()))?;
    let i64_tensor = BitNetTensor::zeros(&[2, 2], BitNetDType::I64, Some(device))?;

    // Validate properties
    assert_eq!(zeros_tensor.dtype(), BitNetDType::F32);
    assert_eq!(ones_tensor.dtype(), BitNetDType::F32);
    assert_eq!(i32_tensor.dtype(), BitNetDType::I32);
    assert_eq!(i64_tensor.dtype(), BitNetDType::I64);

    println!("✅ Tensor creation patterns test passed!");
    Ok(())
}

/// Test validation helper concepts (without missing APIs)
#[test]
fn test_validation_helpers_concept() {
    // Test shape validation concept
    let shape1 = vec![2, 3, 4];
    let shape2 = vec![2, 3, 4];
    let shape3 = vec![2, 3, 5];

    assert_eq!(shape1, shape2);
    assert_ne!(shape1, shape3);

    // Test dtype validation concept
    let dtype1 = BitNetDType::F32;
    let dtype2 = BitNetDType::F32;
    let dtype3 = BitNetDType::I32;

    assert_eq!(dtype1, dtype2);
    assert_ne!(dtype1, dtype3);

    println!("✅ Validation helpers concept test passed!");
}
